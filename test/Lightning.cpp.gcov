        -:    0:Source:/home/runner/work/BresserWeatherSensorReceiver/BresserWeatherSensorReceiver/src/Lightning.cpp
        -:    0:Graph:build/RainGauge/objs/home/runner/work/BresserWeatherSensorReceiver/BresserWeatherSensorReceiver/src/Lightning.gcno
        -:    0:Data:build/RainGauge/objs/home/runner/work/BresserWeatherSensorReceiver/BresserWeatherSensorReceiver/src/Lightning.gcda
        -:    0:Runs:1
        -:    1:///////////////////////////////////////////////////////////////////////////////////////////////////
        -:    2:// Lightning.cpp
        -:    3://
        -:    4:// Post-processing of lightning sensor data
        -:    5://
        -:    6:// Input:
        -:    7://     * Timestamp
        -:    8://     * Sensor startup flag
        -:    9://     * Accumulated lightning event counter
        -:   10://     * Estimated distance of last strike
        -:   11://
        -:   12:// Output:
        -:   13://     * Number of events during last update cycle
        -:   14://     * Timestamp, number of strikes and estimated distance of last event
        -:   15://     * Number of strikes during past 60 minutes
        -:   16://
        -:   17:// Non-volatile data is stored in the ESP32's RTC RAM or in Preferences (Flash FS)
        -:   18:// to allow retention during deep sleep mode.
        -:   19://
        -:   20:// https://github.com/matthias-bs/BresserWeatherSensorReceiver
        -:   21://
        -:   22://
        -:   23:// created: 07/2023
        -:   24://
        -:   25://
        -:   26:// MIT License
        -:   27://
        -:   28:// Copyright (c) 2023 Matthias Prinke
        -:   29:// 
        -:   30:// Permission is hereby granted, free of charge, to any person obtaining a copy
        -:   31:// of this software and associated documentation files (the "Software"), to deal
        -:   32:// in the Software without restriction, including without limitation the rights
        -:   33:// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:   34:// copies of the Software, and to permit persons to whom the Software is
        -:   35:// furnished to do so, subject to the following conditions:
        -:   36:// 
        -:   37:// The above copyright notice and this permission notice shall be included in all
        -:   38:// copies or substantial portions of the Software.
        -:   39:// 
        -:   40:// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   41:// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   42:// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   43:// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   44:// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   45:// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -:   46:// SOFTWARE.
        -:   47://
        -:   48:// History:
        -:   49://
        -:   50:// 20230721 Created
        -:   51:// 20231105 Added data storage via Preferences, modified history implementation
        -:   52:// 20240113 Fixed timestamp format string and hourly history calculation
        -:   53:// 20240114 Implemented counter overflow and startup handling
        -:   54:// 20240119 Changed preferences to class member
        -:   55:// 20240123 Changed scope of nvLightning -
        -:   56://          Using RTC RAM: global
        -:   57://          Using Preferences, Unit Tests: class member
        -:   58://          Modified for unit testing
        -:   59://          Modified pastHour()
        -:   60://          Added qualityThreshold
        -:   61:// 20240124 Fixed handling of overflow, startup and missing update cycles
        -:   62:// 20240125 Added lastCycle()
        -:   63:// 20240130 Update pastHour() documentation
        -:   64:// 20250324 Added configuration of expected update rate at run-time
        -:   65://          pastHour(): modified parameters
        -:   66:// 20260211 Refactored to use RollingCounter base class
        -:   67:// 20260221 Improved RollingCounter generalization, documentation, and code deduplication
        -:   68://
        -:   69:// ToDo:
        -:   70:// -
        -:   71://
        -:   72:// Notes:
        -:   73:// Maximum number of lightning strikes on earth:
        -:   74:// https://en.wikipedia.org/wiki/Catatumbo_lightning
        -:   75://
        -:   76:///////////////////////////////////////////////////////////////////////////////////////////////////
        -:   77:
        -:   78:#include <Arduino.h>
        -:   79:#include "Lightning.h"
        -:   80:
        -:   81:
        -:   82:#if !defined(LIGHTNING_USE_PREFS) && !defined(INSIDE_UNITTEST)
        -:   83:RTC_DATA_ATTR nvLightning_t nvLightning = {
        -:   84:    .lastUpdate = 0,
        -:   85:    .startupPrev = false,
        -:   86:    .preStCount = 0,
        -:   87:    .accCount = 0,
        -:   88:    .prevCount = -1,
        -:   89:    .events = 0,
        -:   90:    .distance = 0,
        -:   91:    .timestamp = 0,
        -:   92:    .hist = {0},
        -:   93:    .updateRate = LIGHTNING_UPD_RATE
        -:   94:};
        -:   95:#endif
        -:   96:
        -:   97:void
        1:   98:Lightning::reset(void)
        -:   99:{
        1:  100:    nvLightning.lastUpdate = 0;
        1:  101:    nvLightning.startupPrev = false;
        1:  102:    nvLightning.preStCount = 0;
        1:  103:    nvLightning.prevCount = -1;
        1:  104:    nvLightning.accCount = 0;
        1:  105:    nvLightning.events = -1;
        1:  106:    nvLightning.distance = 0;
        1:  107:    nvLightning.timestamp = 0;
        1:  108:    deltaEvents = -1;
        1:  109:}
        -:  110:
        -:  111:void
       18:  112:Lightning::hist_init(int16_t count)
        -:  113:{
      198:  114:    for (int i=0; i<LIGHTNING_HIST_SIZE; i++) {
      180:  115:        nvLightning.hist[i] = count;
        -:  116:    }
       18:  117:}
        -:  118:
        -:  119:#if defined(LIGHTNING_USE_PREFS)  && !defined(INSIDE_UNITTEST)
        -:  120:void Lightning::prefs_load(void)
        -:  121:{
        -:  122:    preferences.begin("BWS-LGT", false);
        -:  123:    nvLightning.lastUpdate   = preferences.getULong64("lastUpdate", 0);
        -:  124:    nvLightning.startupPrev  = preferences.getBool("startupPrev", false);
        -:  125:    nvLightning.preStCount   = preferences.getShort("preStCount", 0);
        -:  126:    nvLightning.accCount     = preferences.getUInt("accCount", 0);
        -:  127:    nvLightning.prevCount    = preferences.getUShort("prevCount", -1);
        -:  128:    nvLightning.events       = preferences.getUShort("events", -1);
        -:  129:    nvLightning.distance     = preferences.getUChar("distance", 0);
        -:  130:    nvLightning.timestamp    = preferences.getULong64("timestamp", 0);
        -:  131:    nvLightning.updateRate   = preferences.getUChar("updateRate", LIGHTNING_UPD_RATE);
        -:  132:    //preferences.getBytes("hist", nvLightning.hist, sizeof(nvLightning.hist));
        -:  133:    // Optimization: Reduces number of Flash writes
        -:  134:    for (int i=0; i<LIGHTNING_HIST_SIZE; i++) {
        -:  135:        char buf[7];
        -:  136:        sprintf(buf, "hist%02d", i);
        -:  137:        nvLightning.hist[i] = preferences.getShort(buf, -1);
        -:  138:    }
        -:  139:    log_d("lastUpdate   =%s", String(nvLightning.lastUpdate).c_str());
        -:  140:    log_d("startupPrev  =%d", nvLightning.startupPrev);
        -:  141:    log_d("preStCount   =%d", nvLightning.preStCount);
        -:  142:    log_d("accCount     =%u", nvLightning.accCount);
        -:  143:    log_d("prevCount    =%d", nvLightning.prevCount);
        -:  144:    log_d("events       =%d", nvLightning.events);
        -:  145:    log_d("distance     =%d", nvLightning.distance);
        -:  146:    log_d("timestamp    =%s", String(nvLightning.timestamp).c_str());
        -:  147:    preferences.end();
        -:  148:}
        -:  149:
        -:  150:void Lightning::prefs_save(void)
        -:  151:{
        -:  152:    preferences.begin("BWS-LGT", false);
        -:  153:    preferences.putULong64("lastUpdate", nvLightning.lastUpdate);
        -:  154:    preferences.putBool("startupPrev", nvLightning.startupPrev);
        -:  155:    preferences.putShort("preStCount", nvLightning.preStCount);
        -:  156:    preferences.putUInt("accCount", nvLightning.accCount);
        -:  157:    preferences.putUShort("prevCount", nvLightning.prevCount);
        -:  158:    preferences.putUShort("events", nvLightning.events);
        -:  159:    preferences.putUChar("distance", nvLightning.distance);
        -:  160:    preferences.putULong64("timestamp", nvLightning.timestamp);
        -:  161:    //preferences.putBytes("hist", nvLightning.hist, sizeof(nvLightning.hist));
        -:  162:    // Optimization: Reduces number of Flash writes
        -:  163:    for (int i=0; i<LIGHTNING_HIST_SIZE; i++) {
        -:  164:        char buf[7];
        -:  165:        sprintf(buf, "hist%02d", i);
        -:  166:        preferences.putShort(buf, nvLightning.hist[i]);
        -:  167:    }
        -:  168:    preferences.end();
        -:  169:}
        -:  170:#endif
        -:  171:
        -:  172:void
       61:  173:Lightning::update(time_t timestamp, int16_t count, uint8_t distance, bool startup)
        -:  174:{
        -:  175:    #if defined(LIGHTNING_USE_PREFS)  && !defined(INSIDE_UNITTEST)
        -:  176:        prefs_load();
        -:  177:    #endif
        -:  178:
       61:  179:    if (nvLightning.lastUpdate == 0) {
        -:  180:        // Initialize history
        8:  181:        hist_init();
        -:  182:    }
        -:  183:
       61:  184:    if (nvLightning.prevCount == -1) {
        -:  185:        // No previous count or counter reset
        8:  186:        nvLightning.prevCount = count;
        8:  187:        nvLightning.lastUpdate = timestamp;
        8:  188:        lastUpdate = timestamp;
        -:  189:
        -:  190:        #if defined(LIGHTNING_USE_PREFS)  && !defined(INSIDE_UNITTEST)
        -:  191:            prefs_save();
        -:  192:        #endif
        -:  193:    }
        -:  194:    
       61:  195:    currCount = nvLightning.accCount + count;
        -:  196:
       61:  197:    if (currCount < nvLightning.prevCount) {
        -:  198:       // Startup change 0->1 detected
        2:  199:       if (!nvLightning.startupPrev && startup) {
        -:  200:           // Add last counter reading before startup
        1:  201:           nvLightning.accCount += nvLightning.preStCount;
        -:  202:       } else {
        -:  203:           // Add counter overflow
        1:  204:           nvLightning.accCount += LIGHTNINGCOUNT_MAX_VALUE;
        -:  205:       }
        -:  206:    }
        -:  207:
       61:  208:    currCount = nvLightning.accCount + count;
       61:  209:    nvLightning.startupPrev = startup;
       61:  210:    nvLightning.preStCount = count;
        -:  211:
        -:  212:    /**
        -:  213:     * \verbatim
        -:  214:     * Total number of events during past 60 minutes
        -:  215:     * ----------------------------------------------
        -:  216:     * 
        -:  217:     * In each update():
        -:  218:     * - timestamp (time_t) ->                  t (localtime, struct tm)
        -:  219:     * - calculate index into hist[]:           idx = t.tm_min / updateRate
        -:  220:     * - expired time since last update:        t_delta = timestamp - nvLightning.lastUpdate
        -:  221:     * - number of events since last update:    delta = currCount - nvLightning.prevCount
        -:  222:     * - t_delta
        -:  223:     *      < 0:                                something is wrong, e.g. RTC was not set correctly -> ignore, return
        -:  224:     *      t_delta < expected update rate:
        -:  225:     *          idx same as in previous cycle:  hist[idx] += delta
        -:  226:     *          idx changed by 1:               hist[idx] = delta
        -:  227:     *      t_delta >= history size:            mark all history entries as invalid
        -:  228:     *      else (index changed > 1):           mark all history entries in interval [expected_index, current_index) as invalid
        -:  229:     *                                          hist[idx] = delta
        -:  230:     *
        -:  231:     *   ---------------     -----------
        -:  232:     *  |   |   |   |   |...|   |   |   |   hist[LIGHTNING_HIST_SIZE]
        -:  233:     *   ---------------     -----------
        -:  234:     *        ^
        -:  235:     *        |
        -:  236:     *       idx = t.tm_min / updateRate
        -:  237:     *
        -:  238:     * - Calculate hourly rate:
        -:  239:     *   pastHour = sum of all valid hist[] entries
        -:  240:     *
        -:  241:     * \endverbatim
        -:  242:     */
        -:  243:
        -:  244:    // Delta time between last update and current time
       61:  245:    time_t t_delta = timestamp - nvLightning.lastUpdate;
       61:  246:    log_d("t_delta: %ld", t_delta);
        -:  247:
        -:  248:    // t_delta < 0: something is wrong, e.g. RTC was not set correctly
       61:  249:    if (t_delta < 0) {
        1:  250:        log_w("Negative time span since last update!?");
        1:  251:        return; 
        -:  252:    }
        -:  253:
        -:  254:
       60:  255:    int16_t delta = currCount - nvLightning.prevCount;
       60:  256:    deltaEvents = delta;
        -:  257:
       60:  258:    if (delta > 0) {
        -:  259:        // Save detected event
       51:  260:        nvLightning.events = delta;
       51:  261:        nvLightning.distance = distance;
       51:  262:        nvLightning.timestamp = timestamp;
        -:  263:    }
        -:  264:
        -:  265:
        -:  266:    struct tm timeinfo;
       60:  267:    localtime_r(&timestamp, &timeinfo);
       60:  268:    int idx = calculateIndex(timeinfo, nvLightning.updateRate);
        -:  269:
        -:  270:    // Update history buffer using generalized base class method
       60:  271:    updateHistoryBuffer(nvLightning.hist, LIGHTNING_HIST_SIZE, idx, delta,
       60:  272:                       t_delta, timestamp, nvLightning.lastUpdate, nvLightning.updateRate);
        -:  273:    
        -:  274:    #if CORE_DEBUG_LEVEL == ARDUHAL_LOG_LEVEL_DEBUG
        -:  275:        String buf;
       60:  276:        buf = String("hist[]={");
      660:  277:        for (size_t i=0; i<LIGHTNING_HIST_SIZE; i++) {
      600:  278:            buf += String(nvLightning.hist[i]) + String(", ");
        -:  279:        }
       60:  280:        buf += String("}");
       60:  281:        log_d("%s", buf.c_str());
        -:  282:    #endif
        -:  283:
       60:  284:    nvLightning.lastUpdate = timestamp;
       60:  285:    lastUpdate = timestamp;
       60:  286:    updateRate = nvLightning.updateRate;
       60:  287:    nvLightning.prevCount = currCount;
        -:  288:
        -:  289:    #if defined(LIGHTNING_USE_PREFS)  && !defined(INSIDE_UNITTEST)
        -:  290:        prefs_save();
        -:  291:    #endif
       60:  292:}
        -:  293:
        -:  294:int 
        6:  295:Lightning::lastCycle(void)
        -:  296:{
        6:  297:    return deltaEvents;
        -:  298:}
        -:  299:
        -:  300:bool
        5:  301:Lightning::lastEvent(time_t &timestamp, int &events, uint8_t &distance)
        -:  302:{
        5:  303:    if (nvLightning.events == -1) {
        1:  304:        events = -1;
        1:  305:        return false;
        -:  306:    }
        -:  307:
        4:  308:    events = nvLightning.events;
        4:  309:    distance = nvLightning.distance;
        4:  310:    timestamp = nvLightning.timestamp;
        -:  311:
        4:  312:    return true;
        -:  313:}
        -:  314:
        -:  315:int
       57:  316:Lightning::pastHour(bool *valid, int *nbins, float *quality)
        -:  317:{
       57:  318:    History hourHist = {
       57:  319:        .hist = nvLightning.hist,
        -:  320:        .size = LIGHTNING_HIST_SIZE,
       57:  321:        .updateRate = nvLightning.updateRate
       57:  322:    };
      114:  323:    return static_cast<int>(sumHistory(hourHist, valid, nbins, quality, 1.0));
        -:  324:}
