        -:    0:Source:/home/runner/work/BresserWeatherSensorReceiver/BresserWeatherSensorReceiver/src/RollingCounter.cpp
        -:    0:Graph:build/RainGauge/objs/home/runner/work/BresserWeatherSensorReceiver/BresserWeatherSensorReceiver/src/RollingCounter.gcno
        -:    0:Data:build/RainGauge/objs/home/runner/work/BresserWeatherSensorReceiver/BresserWeatherSensorReceiver/src/RollingCounter.gcda
        -:    0:Runs:1
        -:    1:///////////////////////////////////////////////////////////////////////////////////////////////////
        -:    2:// RollingCounter.cpp
        -:    3://
        -:    4:// Base class for rolling counter implementations (RainGauge, Lightning, etc.)
        -:    5:// Provides common functionality for history buffer management and calculations
        -:    6://
        -:    7:// https://github.com/matthias-bs/BresserWeatherSensorReceiver
        -:    8://
        -:    9://
        -:   10:// created: 02/2026
        -:   11://
        -:   12://
        -:   13:// MIT License
        -:   14://
        -:   15:// Copyright (c) 2026 Matthias Prinke
        -:   16:// 
        -:   17:// Permission is hereby granted, free of charge, to any person obtaining a copy
        -:   18:// of this software and associated documentation files (the "Software"), to deal
        -:   19:// in the Software without restriction, including without limitation the rights
        -:   20:// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:   21:// copies of the Software, and to permit persons to whom the Software is
        -:   22:// furnished to do so, subject to the following conditions:
        -:   23:// 
        -:   24:// The above copyright notice and this permission notice shall be included in all
        -:   25:// copies or substantial portions of the Software.
        -:   26:// 
        -:   27:// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   28:// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   29:// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   30:// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   31:// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   32:// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -:   33:// SOFTWARE.
        -:   34://
        -:   35:// History:
        -:   36://
        -:   37:// 20260211 Created from common code in RainGauge and Lightning
        -:   38:// 20260221 Improved generalization, documentation, and code deduplication
        -:   39://
        -:   40:// ToDo: 
        -:   41:// -
        -:   42://
        -:   43:///////////////////////////////////////////////////////////////////////////////////////////////////
        -:   44:
        -:   45:#include <Arduino.h>
        -:   46:#include "WeatherSensorCfg.h"
        -:   47:#include "RollingCounter.h"
        -:   48:
        -:   49:int 
      707:   50:RollingCounter::calculateIndex(const struct tm& tm, uint8_t rate) const
        -:   51:{
      707:   52:    if (rate >= 60) {
        -:   53:        // Hourly or greater - use hour of day (0-23)
      567:   54:        return tm.tm_hour;
        -:   55:    } else {
        -:   56:        // Sub-hourly - use minute within hour divided by rate
      140:   57:        return tm.tm_min / rate;
        -:   58:    }
        -:   59:}
        -:   60:
        -:   61:void 
      212:   62:RollingCounter::markMissedEntries(int16_t* hist, size_t size, time_t lastUpdate, 
        -:   63:                                  time_t timestamp, uint8_t rate)
        -:   64:{
        -:   65:    // Guard against invalid rate values to avoid division by zero
      212:   66:    if (rate == 0) {
        1:   67:        log_w("markMissedEntries called with invalid rate=0, skipping history update");
        1:   68:        return;
        -:   69:    }
        -:   70:
        -:   71:    // Mark all history entries in interval [expected_index, current_index) as invalid
        -:   72:    // N.B.: excluding current index!
      380:   73:    for (time_t ts = lastUpdate + (rate * 60); ts < timestamp; ts += rate * 60) {
        -:   74:        struct tm timeinfo;
      169:   75:        localtime_r(&ts, &timeinfo);
      169:   76:        int idx = calculateIndex(timeinfo, rate);
        -:   77:        
        -:   78:        // Use provided size to guard against out-of-bounds writes
     169*:   79:        if (idx < 0 || static_cast<size_t>(idx) >= size) {
    #####:   80:            log_w("markMissedEntries: computed index %d out of bounds (size=%u, hour=%d, minute=%d, rate=%u)",
        -:   81:                  idx, static_cast<unsigned>(size), timeinfo.tm_hour, timeinfo.tm_min, rate);
    #####:   82:            continue;
        -:   83:        }
        -:   84:        
      169:   85:        hist[idx] = -1;
      169:   86:        log_d("hist[%d]=-1", idx);
        -:   87:    }
        -:   88:}
        -:   89:
        -:   90:float 
      196:   91:RollingCounter::sumHistory(const History& h, bool *valid, int *nbins, float *quality, float scale)
        -:   92:{
      196:   93:    int entries = 0;
      196:   94:    float res = 0;
        -:   95:
        -:   96:    // Validate updateRate to avoid division by zero
      196:   97:    if (h.updateRate == 0) {
    #####:   98:        log_w("sumHistory called with invalid updateRate=0");
    #####:   99:        if (nbins != nullptr)
    #####:  100:            *nbins = 0;
    #####:  101:        if (valid != nullptr)
    #####:  102:            *valid = false;
    #####:  103:        if (quality != nullptr)
    #####:  104:            *quality = 0.0f;
    #####:  105:        return 0.0f;
        -:  106:    }
        -:  107:
        -:  108:    // Calculate the effective number of bins based on size and update rate
        -:  109:    // For hourly buffer: 60 minutes / updateRate = number of bins
        -:  110:    // For 24h buffer: size is already correct (24 bins for 24 hours)
        -:  111:    size_t effectiveBins;
      196:  112:    if (h.updateRate == 60) {
        -:  113:        // 24-hour buffer: size is already the effective bin count
       14:  114:        effectiveBins = h.size;
      182:  115:    } else if (h.updateRate > 60) {
        -:  116:        // Invalid rate for hourly buffer, can't have update rate > 60 minutes
    #####:  117:        log_w("sumHistory called with updateRate=%u > 60 minutes", h.updateRate);
    #####:  118:        effectiveBins = 1; // Fallback to avoid division by zero
        -:  119:    } else {
        -:  120:        // Hourly buffer: calculate bins based on update rate
      182:  121:        effectiveBins = 60 / h.updateRate;
        -:  122:        // Constrain to actual buffer size
      182:  123:        if (effectiveBins > h.size) {
        2:  124:            effectiveBins = h.size;
        -:  125:        }
        -:  126:    }
        -:  127:
        -:  128:    // Sum of all valid entries, but only count bins within the effective range
      196:  129:    size_t binsToCheck = (effectiveBins < h.size) ? effectiveBins : h.size;
     2276:  130:    for (size_t i = 0; i < binsToCheck; i++){
     2080:  131:        if (h.hist[i] >= 0) {
      970:  132:            res += h.hist[i] * scale;
      970:  133:            entries++;
        -:  134:        }
        -:  135:    }
        -:  136:
        -:  137:    // Optional: return number of valid bins
      196:  138:    if (nbins != nullptr)
       72:  139:        *nbins = entries;
        -:  140:    
        -:  141:    // Optional: return valid flag
      196:  142:    if (valid != nullptr) {
       79:  143:        if (entries >= qualityThreshold * effectiveBins) {
       30:  144:            *valid = true;
        -:  145:        } else {
       49:  146:            *valid = false;
        -:  147:        }
        -:  148:    }
        -:  149:
        -:  150:    // Optional: return quality
      196:  151:    if (quality != nullptr) {
       42:  152:        if (effectiveBins > 0) {
       42:  153:            *quality = static_cast<float>(entries) / effectiveBins;
        -:  154:        } else {
    #####:  155:            *quality = 0.0f;
        -:  156:        }
        -:  157:    }
        -:  158:
      196:  159:    return res;
        -:  160:}
        -:  161:
        -:  162:RollingCounter::UpdateResult
      628:  163:RollingCounter::updateHistoryBufferCore(int16_t* hist, size_t size, int idx, int16_t delta,
        -:  164:                                       time_t t_delta, time_t timestamp, time_t lastUpdate,
        -:  165:                                       uint8_t updateRate)
        -:  166:{
      628:  167:    if (t_delta / 60 < updateRate) {
        -:  168:        // t_delta shorter than expected update rate
      192:  169:        if (hist[idx] < 0)
       81:  170:            hist[idx] = 0;
        -:  171:        struct tm t_prev;
      192:  172:        localtime_r(&lastUpdate, &t_prev);
      192:  173:        if (calculateIndex(t_prev, updateRate) == idx) {
        -:  174:            // same index as in previous cycle - add value
      163:  175:            hist[idx] += delta;
      163:  176:            log_d("hist[%d]=%d (upd)", idx, hist[idx]);
        -:  177:        } else {
        -:  178:            // different index - new value
       29:  179:            hist[idx] = delta;
       29:  180:            log_d("hist[%d]=%d (new)", idx, hist[idx]);
        -:  181:        }
      192:  182:        return UPDATE_SUCCESS;
        -:  183:    }
      436:  184:    else if (t_delta >= size * updateRate * 60) {
        -:  185:        // t_delta >= HIST_SIZE * UPDATE_RATE -> reset history
      225:  186:        log_w("History time frame expired, resetting!");
      225:  187:        return UPDATE_EXPIRED;
        -:  188:    }
        -:  189:    else {
        -:  190:        // Some other index
        -:  191:        
        -:  192:        // Mark missed entries
      211:  193:        markMissedEntries(hist, size, lastUpdate, timestamp, updateRate);
        -:  194:        
        -:  195:        // Write delta
      211:  196:        hist[idx] = delta;
      211:  197:        log_d("hist[%d]=%d", idx, delta);
      211:  198:        return UPDATE_SUCCESS;
        -:  199:    }
        -:  200:}
        -:  201:
        -:  202:void
      344:  203:RollingCounter::updateHistoryBuffer(int16_t* hist, size_t size, int idx, int16_t delta,
        -:  204:                                   time_t t_delta, time_t timestamp, time_t lastUpdate,
        -:  205:                                   uint8_t updateRate)
        -:  206:{
      344:  207:    UpdateResult result = updateHistoryBufferCore(hist, size, idx, delta, t_delta, 
        -:  208:                                                  timestamp, lastUpdate, updateRate);
      344:  209:    if (result == UPDATE_EXPIRED) {
      142:  210:        hist_init();
        -:  211:    }
      344:  212:}
