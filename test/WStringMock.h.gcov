        -:    0:Source:/home/runner/work/BresserWeatherSensorReceiver/BresserWeatherSensorReceiver/test/mocks/WStringMock.h
        -:    0:Graph:build/RainGauge/objs/home/runner/work/BresserWeatherSensorReceiver/BresserWeatherSensorReceiver/src/Lightning.gcno
        -:    0:Data:build/RainGauge/objs/home/runner/work/BresserWeatherSensorReceiver/BresserWeatherSensorReceiver/src/Lightning.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: WString.h - String library for Wiring & Arduino
        -:    3: ...mostly rewritten by Paul Stoffregen...
        -:    4: Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
        -:    5: Copyright 2011, Paul Stoffregen, paul@pjrc.com
        -:    6:
        -:    7: This library is free software; you can redistribute it and/or
        -:    8: modify it under the terms of the GNU Lesser General Public
        -:    9: License as published by the Free Software Foundation; either
        -:   10: version 2.1 of the License, or (at your option) any later version.
        -:   11:
        -:   12: This library is distributed in the hope that it will be useful,
        -:   13: but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   14: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -:   15: Lesser General Public License for more details.
        -:   16:
        -:   17: You should have received a copy of the GNU Lesser General Public
        -:   18: License along with this library; if not, write to the Free Software
        -:   19: Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
        -:   20: */
        -:   21:
        -:   22:#ifndef String_class_h
        -:   23:#define String_class_h
        -:   24:#ifdef __cplusplus
        -:   25:
        -:   26:#include <stdlib.h>
        -:   27:#include <string.h>
        -:   28:#include <ctype.h>
        -:   29:#include <stdint.h>
        -:   30:#include <inttypes.h>
        -:   31:
        -:   32:#define PROGMEM
        -:   33:#define PGM_P  const char *
        -:   34:#define PSTR(str) (str)
        -:   35:
        -:   36:#define _SFR_BYTE(n) (n)
        -:   37:
        -:   38:typedef void prog_void;
        -:   39:typedef char prog_char;
        -:   40:typedef unsigned char prog_uchar;
        -:   41:typedef int8_t prog_int8_t;
        -:   42:typedef uint8_t prog_uint8_t;
        -:   43:typedef int16_t prog_int16_t;
        -:   44:typedef uint16_t prog_uint16_t;
        -:   45:typedef int32_t prog_int32_t;
        -:   46:typedef uint32_t prog_uint32_t;
        -:   47:typedef int64_t prog_int64_t;
        -:   48:typedef uint64_t prog_uint64_t;
        -:   49:
        -:   50:typedef const void *int_farptr_t;
        -:   51:typedef const void *uint_farptr_t;
        -:   52:
        -:   53:#define memchr_P(s, c, n) memchr((s), (c), (n))
        -:   54:#define memcmp_P(s1, s2, n) memcmp((s1), (s2), (n))
        -:   55:#define memccpy_P(dest, src, c, n) memccpy((dest), (src), (c), (n))
        -:   56:#define memcpy_P(dest, src, n) memcpy((dest), (src), (n))
        -:   57:#define memmem_P(haystack, haystacklen, needle, needlelen) memmem((haystack), (haystacklen), (needle), (needlelen))
        -:   58:#define memrchr_P(s, c, n) memrchr((s), (c), (n))
        -:   59:#define strcat_P(dest, src) strcat((dest), (src))
        -:   60:#define strchr_P(s, c) strchr((s), (c))
        -:   61:#define strchrnul_P(s, c) strchrnul((s), (c))
        -:   62:#define strcmp_P(a, b) strcmp((a), (b))
        -:   63:#define strcpy_P(dest, src) strcpy((dest), (src))
        -:   64:#define strcasecmp_P(s1, s2) strcasecmp((s1), (s2))
        -:   65:#define strcasestr_P(haystack, needle) strcasestr((haystack), (needle))
        -:   66:#define strcspn_P(s, accept) strcspn((s), (accept))
        -:   67:#define strlcat_P(s1, s2, n) strlcat((s1), (s2), (n))
        -:   68:#define strlcpy_P(s1, s2, n) strlcpy((s1), (s2), (n))
        -:   69:#define strlen_P(a) strlen((a))
        -:   70:#define strnlen_P(s, n) strnlen((s), (n))
        -:   71:#define strncmp_P(s1, s2, n) strncmp((s1), (s2), (n))
        -:   72:#define strncasecmp_P(s1, s2, n) strncasecmp((s1), (s2), (n))
        -:   73:#define strncat_P(s1, s2, n) strncat((s1), (s2), (n))
        -:   74:#define strncpy_P(s1, s2, n) strncpy((s1), (s2), (n))
        -:   75:#define strpbrk_P(s, accept) strpbrk((s), (accept))
        -:   76:#define strrchr_P(s, c) strrchr((s), (c))
        -:   77:#define strsep_P(sp, delim) strsep((sp), (delim))
        -:   78:#define strspn_P(s, accept) strspn((s), (accept))
        -:   79:#define strstr_P(a, b) strstr((a), (b))
        -:   80:#define strtok_P(s, delim) strtok((s), (delim))
        -:   81:#define strtok_rP(s, delim, last) strtok((s), (delim), (last))
        -:   82:
        -:   83:#define strlen_PF(a) strlen((a))
        -:   84:#define strnlen_PF(src, len) strnlen((src), (len))
        -:   85:#define memcpy_PF(dest, src, len) memcpy((dest), (src), (len))
        -:   86:#define strcpy_PF(dest, src) strcpy((dest), (src))
        -:   87:#define strncpy_PF(dest, src, len) strncpy((dest), (src), (len))
        -:   88:#define strcat_PF(dest, src) strcat((dest), (src))
        -:   89:#define strlcat_PF(dest, src, len) strlcat((dest), (src), (len))
        -:   90:#define strncat_PF(dest, src, len) strncat((dest), (src), (len))
        -:   91:#define strcmp_PF(s1, s2) strcmp((s1), (s2))
        -:   92:#define strncmp_PF(s1, s2, n) strncmp((s1), (s2), (n))
        -:   93:#define strcasecmp_PF(s1, s2) strcasecmp((s1), (s2))
        -:   94:#define strncasecmp_PF(s1, s2, n) strncasecmp((s1), (s2), (n))
        -:   95:#define strstr_PF(s1, s2) strstr((s1), (s2))
        -:   96:#define strlcpy_PF(dest, src, n) strlcpy((dest), (src), (n))
        -:   97:#define memcmp_PF(s1, s2, n) memcmp((s1), (s2), (n))
        -:   98:
        -:   99:#define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
        -:  100:
        -:  101:#define pgm_read_byte(addr) (*(const unsigned char *)(addr))
        -:  102:#define pgm_read_word(addr) (*(const unsigned short *)(addr))
        -:  103:#define pgm_read_dword(addr) (*(const unsigned long *)(addr))
        -:  104:#define pgm_read_float(addr) (*(const float *)(addr))
        -:  105:#define pgm_read_ptr(addr) (*(const void *)(addr))
        -:  106:
        -:  107:#define pgm_read_byte_near(addr) pgm_read_byte(addr)
        -:  108:#define pgm_read_word_near(addr) pgm_read_word(addr)
        -:  109:#define pgm_read_dword_near(addr) pgm_read_dword(addr)
        -:  110:#define pgm_read_float_near(addr) pgm_read_float(addr)
        -:  111:#define pgm_read_ptr_near(addr) pgm_read_ptr(addr)
        -:  112:
        -:  113:#define pgm_read_byte_far(addr) pgm_read_byte(addr)
        -:  114:#define pgm_read_word_far(addr) pgm_read_word(addr)
        -:  115:#define pgm_read_dword_far(addr) pgm_read_dword(addr)
        -:  116:#define pgm_read_float_far(addr) pgm_read_float(addr)
        -:  117:#define pgm_read_ptr_far(addr) pgm_read_ptr(addr)
        -:  118:
        -:  119:#define pgm_get_far_address(addr) (&(addr))
        -:  120:
        -:  121:// An inherited class for holding the result of a concatenation.  These
        -:  122:// result objects are assumed to be writable by subsequent concatenations.
        -:  123:class StringSumHelper;
        -:  124:
        -:  125:// an abstract class used as a means to proide a unique pointer type
        -:  126:// but really has no body
        -:  127:class __FlashStringHelper;
        -:  128:#define FPSTR(pstr_pointer) (reinterpret_cast<const __FlashStringHelper *>(pstr_pointer))
        -:  129:#define F(string_literal) (FPSTR(PSTR(string_literal)))
        -:  130:
        -:  131:// The string class
        -:  132:class String {
        -:  133:	// use a function pointer to allow for "if (s)" without the
        -:  134:	// complications of an operator bool(). for more information, see:
        -:  135:	// http://www.artima.com/cppsource/safebool.html
        -:  136:	typedef void (String::*StringIfHelperType)() const;
        -:  137:	void StringIfHelper() const {
        -:  138:	}
        -:  139:
        -:  140:public:
        -:  141:	// constructors
        -:  142:	// creates a copy of the initial value.
        -:  143:	// if the initial value is null or invalid, or if memory allocation
        -:  144:	// fails, the string will be marked as invalid (i.e. "if (s)" will
        -:  145:	// be false).
       60:  146:	String() __attribute__((always_inline)) { // See init()
        -:  147:		init();
       60:  148:	}
        -:  149:	String(const char *cstr);
        -:  150:	String(const String &str);
        -:  151:	String(const __FlashStringHelper *str);
        -:  152:	String(String &&rval) noexcept;
        -:  153:	String(StringSumHelper &&rval) noexcept;
        -:  154:	explicit String(char c) {
        -:  155:		sso.buff[0] = c;
        -:  156:		sso.buff[1] = 0;
        -:  157:		sso.len = 1;
        -:  158:		sso.isHeap = 0;
        -:  159:	}
        -:  160:	explicit String(unsigned char, unsigned char base = 10);
        -:  161:	explicit String(int, unsigned char base = 10);
        -:  162:	explicit String(unsigned int, unsigned char base = 10);
        -:  163:	explicit String(long, unsigned char base = 10);
        -:  164:	explicit String(unsigned long, unsigned char base = 10);
        -:  165:	explicit String(long long /* base 10 */);
        -:  166:	explicit String(long long, unsigned char base);
        -:  167:	explicit String(unsigned long long /* base 10 */);
        -:  168:	explicit String(unsigned long long, unsigned char base);
        -:  169:	explicit String(float, unsigned char decimalPlaces = 2);
        -:  170:	explicit String(double, unsigned char decimalPlaces = 2);
    #####:  171:	~String() {
    #####:  172:		invalidate();
    #####:  173:	}
        -:  174:
        -:  175:	// memory management
        -:  176:	// return true on success, false on failure (in which case, the string
        -:  177:	// is left unchanged).  reserve(0), if successful, will validate an
        -:  178:	// invalid string (i.e., "if (s)" will be true afterwards)
        -:  179:	unsigned char reserve(unsigned int size);
        -:  180:	unsigned int length(void) const {
        -:  181:		return buffer() ? len() : 0;
        -:  182:	}
        -:  183:	void clear(void) {
        -:  184:		setLen(0);
        -:  185:	}
        -:  186:	bool isEmpty(void) const {
        -:  187:		return length() == 0;
        -:  188:	}
        -:  189:
        -:  190:	// creates a copy of the assigned value.  if the value is null or
        -:  191:	// invalid, or if the memory allocation fails, the string will be
        -:  192:	// marked as invalid ("if (s)" will be false).
        -:  193:	String& operator =(const String &rhs);
        -:  194:	String& operator =(const char *cstr);
        -:  195:	String& operator =(const __FlashStringHelper *str);
        -:  196:	String& operator =(String &&rval) noexcept;
        -:  197:	String& operator =(StringSumHelper &&rval) noexcept {
        -:  198:		return operator =((String&&) rval);
        -:  199:	}
        -:  200:
        -:  201:	// concatenate (works w/ built-in types)
        -:  202:
        -:  203:	// returns true on success, false on failure (in which case, the string
        -:  204:	// is left unchanged).  if the argument is null or invalid, the
        -:  205:	// concatenation is considered unsuccessful.
        -:  206:	unsigned char concat(const String &str);
        -:  207:	unsigned char concat(const char *cstr);
        -:  208:	unsigned char concat(char c);
        -:  209:	unsigned char concat(unsigned char c);
        -:  210:	unsigned char concat(int num);
        -:  211:	unsigned char concat(unsigned int num);
        -:  212:	unsigned char concat(long num);
        -:  213:	unsigned char concat(unsigned long num);
        -:  214:	unsigned char concat(long long num);
        -:  215:	unsigned char concat(unsigned long long num);
        -:  216:	unsigned char concat(float num);
        -:  217:	unsigned char concat(double num);
        -:  218:	unsigned char concat(const __FlashStringHelper *str);
        -:  219:	unsigned char concat(const char *cstr, unsigned int length);
        -:  220:
        -:  221:	// if there's not enough memory for the concatenated value, the string
        -:  222:	// will be left unchanged (but this isn't signalled in any way)
    #####:  223:	String& operator +=(const String &rhs) {
    #####:  224:		concat(rhs);
    #####:  225:		return *this;
        -:  226:	}
        -:  227:	String& operator +=(const char *cstr) {
        -:  228:		concat(cstr);
        -:  229:		return *this;
        -:  230:	}
        -:  231:	String& operator +=(char c) {
        -:  232:		concat(c);
        -:  233:		return *this;
        -:  234:	}
        -:  235:	String& operator +=(unsigned char num) {
        -:  236:		concat(num);
        -:  237:		return *this;
        -:  238:	}
        -:  239:	String& operator +=(int num) {
        -:  240:		concat(num);
        -:  241:		return *this;
        -:  242:	}
        -:  243:	String& operator +=(unsigned int num) {
        -:  244:		concat(num);
        -:  245:		return *this;
        -:  246:	}
        -:  247:	String& operator +=(long num) {
        -:  248:		concat(num);
        -:  249:		return *this;
        -:  250:	}
        -:  251:	String& operator +=(unsigned long num) {
        -:  252:		concat(num);
        -:  253:		return *this;
        -:  254:	}
        -:  255:	String& operator +=(long long num) {
        -:  256:		concat(num);
        -:  257:		return *this;
        -:  258:	}
        -:  259:	String& operator +=(unsigned long long num) {
        -:  260:		concat(num);
        -:  261:		return *this;
        -:  262:	}
        -:  263:	String& operator +=(float num) {
        -:  264:		concat(num);
        -:  265:		return *this;
        -:  266:	}
        -:  267:	String& operator +=(double num) {
        -:  268:		concat(num);
        -:  269:		return *this;
        -:  270:	}
        -:  271:	String& operator +=(const __FlashStringHelper *str) {
        -:  272:		concat(str);
        -:  273:		return *this;
        -:  274:	}
        -:  275:
        -:  276:	friend StringSumHelper& operator +(const StringSumHelper &lhs,
        -:  277:			const String &rhs);
        -:  278:	friend StringSumHelper& operator +(const StringSumHelper &lhs,
        -:  279:			const char *cstr);
        -:  280:	friend StringSumHelper& operator +(const StringSumHelper &lhs, char c);
        -:  281:	friend StringSumHelper& operator +(const StringSumHelper &lhs,
        -:  282:			unsigned char num);
        -:  283:	friend StringSumHelper& operator +(const StringSumHelper &lhs, int num);
        -:  284:	friend StringSumHelper& operator +(const StringSumHelper &lhs,
        -:  285:			unsigned int num);
        -:  286:	friend StringSumHelper& operator +(const StringSumHelper &lhs, long num);
        -:  287:	friend StringSumHelper& operator +(const StringSumHelper &lhs,
        -:  288:			unsigned long num);
        -:  289:	friend StringSumHelper& operator +(const StringSumHelper &lhs,
        -:  290:			long long num);
        -:  291:	friend StringSumHelper& operator +(const StringSumHelper &lhs,
        -:  292:			unsigned long long num);
        -:  293:	friend StringSumHelper& operator +(const StringSumHelper &lhs, float num);
        -:  294:	friend StringSumHelper& operator +(const StringSumHelper &lhs, double num);
        -:  295:	friend StringSumHelper& operator +(const StringSumHelper &lhs,
        -:  296:			const __FlashStringHelper *rhs);
        -:  297:
        -:  298:	// comparison (only works w/ Strings and "strings")
        -:  299:	operator StringIfHelperType() const {
        -:  300:		return buffer() ? &String::StringIfHelper : 0;
        -:  301:	}
        -:  302:	int compareTo(const String &s) const;
        -:  303:	unsigned char equals(const String &s) const;
        -:  304:	unsigned char equals(const char *cstr) const;
        -:  305:	unsigned char operator ==(const String &rhs) const {
        -:  306:		return equals(rhs);
        -:  307:	}
        -:  308:	unsigned char operator ==(const char *cstr) const {
        -:  309:		return equals(cstr);
        -:  310:	}
        -:  311:	unsigned char operator !=(const String &rhs) const {
        -:  312:		return !equals(rhs);
        -:  313:	}
        -:  314:	unsigned char operator !=(const char *cstr) const {
        -:  315:		return !equals(cstr);
        -:  316:	}
        -:  317:	unsigned char operator <(const String &rhs) const;
        -:  318:	unsigned char operator >(const String &rhs) const;
        -:  319:	unsigned char operator <=(const String &rhs) const;
        -:  320:	unsigned char operator >=(const String &rhs) const;
        -:  321:	unsigned char equalsIgnoreCase(const String &s) const;
        -:  322:	unsigned char equalsConstantTime(const String &s) const;
        -:  323:	unsigned char startsWith(const String &prefix) const;
        -:  324:	unsigned char startsWith(const char *prefix) const {
        -:  325:		return this->startsWith(String(prefix));
        -:  326:	}
        -:  327:	unsigned char startsWith(const __FlashStringHelper *prefix) const {
        -:  328:		return this->startsWith(String(prefix));
        -:  329:	}
        -:  330:	unsigned char startsWith(const String &prefix, unsigned int offset) const;
        -:  331:	unsigned char endsWith(const String &suffix) const;
        -:  332:	unsigned char endsWith(const char *suffix) const {
        -:  333:		return this->endsWith(String(suffix));
        -:  334:	}
        -:  335:	unsigned char endsWith(const __FlashStringHelper *suffix) const {
        -:  336:		return this->endsWith(String(suffix));
        -:  337:	}
        -:  338:
        -:  339:	// character access
        -:  340:	char charAt(unsigned int index) const {
        -:  341:		return operator [](index);
        -:  342:	}
        -:  343:	void setCharAt(unsigned int index, char c);
        -:  344:	char operator [](unsigned int index) const;
        -:  345:	char& operator [](unsigned int index);
        -:  346:	void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index =
        -:  347:			0) const;
        -:  348:	void toCharArray(char *buf, unsigned int bufsize,
        -:  349:			unsigned int index = 0) const {
        -:  350:		getBytes((unsigned char*) buf, bufsize, index);
        -:  351:	}
    #####:  352:	const char* c_str() const {
    #####:  353:		return buffer();
        -:  354:	}
        -:  355:	char* begin() {
        -:  356:		return wbuffer();
        -:  357:	}
        -:  358:	char* end() {
        -:  359:		return wbuffer() + length();
        -:  360:	}
        -:  361:	const char* begin() const {
        -:  362:		return c_str();
        -:  363:	}
        -:  364:	const char* end() const {
        -:  365:		return c_str() + length();
        -:  366:	}
        -:  367:
        -:  368:	// search
        -:  369:	int indexOf(char ch, unsigned int fromIndex = 0) const;
        -:  370:	int indexOf(const char *str, unsigned int fromIndex = 0) const;
        -:  371:	int indexOf(const __FlashStringHelper *str,
        -:  372:			unsigned int fromIndex = 0) const {
        -:  373:		return indexOf((const char*) str, fromIndex);
        -:  374:	}
        -:  375:	int indexOf(const String &str, unsigned int fromIndex = 0) const;
        -:  376:	int lastIndexOf(char ch) const;
        -:  377:	int lastIndexOf(char ch, unsigned int fromIndex) const;
        -:  378:	int lastIndexOf(const String &str) const;
        -:  379:	int lastIndexOf(const String &str, unsigned int fromIndex) const;
        -:  380:	String substring(unsigned int beginIndex) const {
        -:  381:		return substring(beginIndex, len());
        -:  382:	}
        -:  383:	String substring(unsigned int beginIndex, unsigned int endIndex) const;
        -:  384:
        -:  385:	// modification
        -:  386:	void replace(char find, char replace);
        -:  387:	void replace(const String &find, const String &replace);
        -:  388:	void replace(const char *find, const String &replace) {
        -:  389:		this->replace(String(find), replace);
        -:  390:	}
        -:  391:	void replace(const __FlashStringHelper *find, const String &replace) {
        -:  392:		this->replace(String(find), replace);
        -:  393:	}
        -:  394:	void replace(const char *find, const char *replace) {
        -:  395:		this->replace(String(find), String(replace));
        -:  396:	}
        -:  397:	void replace(const __FlashStringHelper *find, const char *replace) {
        -:  398:		this->replace(String(find), String(replace));
        -:  399:	}
        -:  400:	void replace(const __FlashStringHelper *find,
        -:  401:			const __FlashStringHelper *replace) {
        -:  402:		this->replace(String(find), String(replace));
        -:  403:	}
        -:  404:	// Pass the biggest integer if the count is not specified.
        -:  405:	// The remove method below will take care of truncating it at the end of the string.
        -:  406:	void remove(unsigned int index, unsigned int count = (unsigned int) -1);
        -:  407:	void toLowerCase(void);
        -:  408:	void toUpperCase(void);
        -:  409:	void trim(void);
        -:  410:
        -:  411:	// parsing/conversion
        -:  412:	long toInt(void) const;
        -:  413:	float toFloat(void) const;
        -:  414:	double toDouble(void) const;
        -:  415:
        -:  416:protected:
        -:  417:	// Contains the string info when we're not in SSO mode
        -:  418:	struct _ptr {
        -:  419:		char *buff;
        -:  420:		uint16_t cap;
        -:  421:		uint16_t len;
        -:  422:	};
        -:  423:	// This allows strings up up to 11 (10 + \0 termination) without any extra space.
        -:  424:	enum {
        -:  425:		SSOSIZE = sizeof(struct _ptr) + 4 - 1
        -:  426:	}; // Characters to allocate space for SSO, must be 12 or more
        -:  427:	struct _sso {
        -:  428:		char buff[SSOSIZE];
        -:  429:		unsigned char len :7; // Ensure only one byte is allocated by GCC for the bitfields
        -:  430:		unsigned char isHeap :1;
        -:  431:	} __attribute__((packed)); // Ensure that GCC doesn't expand the flag byte to a 32-bit word for alignment issues
        -:  432:	enum {
        -:  433:		CAPACITY_MAX = 65535
        -:  434:	}; // If typeof(cap) changed from uint16_t, be sure to update this enum to the max value storable in the type
        -:  435:	union {
        -:  436:		struct _ptr ptr;
        -:  437:		struct _sso sso;
        -:  438:	};
        -:  439:	// Accessor functions
    #####:  440:	bool isSSO() const {
    #####:  441:		return !sso.isHeap;
        -:  442:	}
        -:  443:	unsigned int len() const {
        -:  444:		return isSSO() ? sso.len : ptr.len;
        -:  445:	}
        -:  446:	unsigned int capacity() const {
        -:  447:		return isSSO() ? (unsigned int) SSOSIZE - 1 : ptr.cap;
        -:  448:	} // Size of max string not including terminal NUL
        -:  449:	void setSSO(bool set) {
        -:  450:		sso.isHeap = !set;
        -:  451:	}
        -:  452:	void setLen(int len) {
        -:  453:		if (isSSO()) {
        -:  454:			setSSO(true); // Avoid emitting of bitwise EXTRACT-AND-OR ops (store-merging optimization)
        -:  455:			sso.len = len;
        -:  456:		} else
        -:  457:			ptr.len = len;
        -:  458:	}
        -:  459:	void setCapacity(int cap) {
        -:  460:		if (!isSSO())
        -:  461:			ptr.cap = cap;
        -:  462:	}
        -:  463:	void setBuffer(char *buff) {
        -:  464:		if (!isSSO())
        -:  465:			ptr.buff = buff;
        -:  466:	}
        -:  467:	// Buffer accessor functions
    #####:  468:	const char* buffer() const {
    #####:  469:		return wbuffer();
        -:  470:	}
    #####:  471:	char* wbuffer() const {
    #####:  472:		return isSSO() ? const_cast<char*>(sso.buff) : ptr.buff;
        -:  473:	} // Writable version of buffer
        -:  474:
        -:  475:protected:
        -:  476:	void init(void) __attribute__((always_inline)) {
       60:  477:		sso.buff[0] = 0;
       60:  478:		sso.len = 0;
       60:  479:		sso.isHeap = 0;
        -:  480:		// Without the 6 statements shown below, GCC simply emits such as: "MOVI.N aX,0", "S8I aX,a2,0" and "S8I aX,a2,11" (8 bytes in total)
       60:  481:		sso.buff[1] = 0;
       60:  482:		sso.buff[2] = 0;
       60:  483:		sso.buff[3] = 0;
       60:  484:		sso.buff[8] = 0;
       60:  485:		sso.buff[9] = 0;
       60:  486:		sso.buff[10] = 0;
        -:  487:		// With the above, thanks to store-merging, GCC can use the narrow form of 32-bit store insn ("S32I.N") and emits:
        -:  488:		//   "MOVI.N aX,0", "S32I.N aX,a2,0" and "S32I.N aX,a2,8" (6 bytes in total)
        -:  489:		// (Literature: Xtensa(R) Instruction Set Reference Manual, "S8I - Store 8-bit" [p.504] and "S32I.N - Narrow Store 32-bit" [p.512])
        -:  490:		// Unfortunately, GCC seems not to re-evaluate the cost of inlining after the store-merging optimizer stage,
        -:  491:		// `always_inline` attribute is necessary in order to keep inlining.
       60:  492:	}
        -:  493:	void invalidate(void);
        -:  494:	unsigned char changeBuffer(unsigned int maxStrLen);
        -:  495:
        -:  496:	// copy and move
        -:  497:	String& copy(const char *cstr, unsigned int length);
        -:  498:	String& copy(const __FlashStringHelper *pstr, unsigned int length);
        -:  499:	void move(String &rhs) noexcept;
        -:  500:};
        -:  501:
        -:  502:class StringSumHelper: public String {
        -:  503:public:
    #####:  504:	StringSumHelper(const String &s) :
    #####:  505:			String(s) {
    #####:  506:	}
        -:  507:	StringSumHelper(const char *p) :
        -:  508:			String(p) {
        -:  509:	}
        -:  510:	StringSumHelper(char c) :
        -:  511:			String(c) {
        -:  512:	}
        -:  513:	StringSumHelper(unsigned char num) :
        -:  514:			String(num) {
        -:  515:	}
        -:  516:	StringSumHelper(int num) :
        -:  517:			String(num) {
        -:  518:	}
        -:  519:	StringSumHelper(unsigned int num) :
        -:  520:			String(num) {
        -:  521:	}
        -:  522:	StringSumHelper(long num) :
        -:  523:			String(num) {
        -:  524:	}
        -:  525:	StringSumHelper(unsigned long num) :
        -:  526:			String(num) {
        -:  527:	}
        -:  528:	StringSumHelper(long long num) :
        -:  529:			String(num) {
        -:  530:	}
        -:  531:	StringSumHelper(unsigned long long num) :
        -:  532:			String(num) {
        -:  533:	}
        -:  534:	StringSumHelper(float num) :
        -:  535:			String(num) {
        -:  536:	}
        -:  537:	StringSumHelper(double num) :
        -:  538:			String(num) {
        -:  539:	}
        -:  540:	StringSumHelper(const __FlashStringHelper *s) :
        -:  541:			String(s) {
        -:  542:	}
        -:  543:};
        -:  544:
        -:  545:extern const String emptyString;
        -:  546:
        -:  547:#endif  // __cplusplus
        -:  548:#endif  // String_class_h
